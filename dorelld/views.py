from pyramid.view import view_config
from pyramid.response import Response, FileResponse

import os,shutil,tempfile,zipfile
from urllib import parse,request

    # We need a link to a temporary download folder
d = os.path.dirname(__file__)
	
    # Download function
    ## This is an actual link, 'doreco.info/doreLoad'
    ## Returns a url to a '.zip' file
@view_config(route_name='doreLoad')
def doreLoad(req):
    """Downloads files from NAKALA then returns a '.zip'.
    ARGUMENTS:
    - 'req'     :   a request generated by POST
    - 'id'      :   (in 'req') the language name
    - 'wav'     :   (in 'req') if WAV files are included
    - 'format'  :   (in 'req') the file format
    RETURNS:
    - a url to a '.zip' file for download
    Note: all arguments are strings
    Note: 'lang_n=language' means all languages
    Note: The process can be lengthy, to recover each and every file,
          then zip them, then delete all but the zip file.
          If the zip file already exists, though, it is directly returned."""
    
        # request variables
    lang_n = req.POST.get('id')
    wav_n = req.POST.get('wav',"False")
    format_n = req.POST.get('format')
        # If those variables are missing
    if not lang_n or not format_n:
        return Response("<!DOCTYPE html>"
                "<html><head><title>DoReCo download service</title></head>"
                "<body><h1>DoReCo download service</h1><p>This link calls "
                "a function to download DoReCo resources. But it requires "
                "more parameters.</p>"
                "<p>Please POST {id=\"glottocode\", format=\"format\"}.</p>"
                "</body></html>")
    
        #### We work from there ####
        # This could be done in a separate function but eh.
    
        # Variables
    s_path = "/data/downloads"                  # download dir_path
    nakala = "https://www.nakala.fr/data"       # nakala data url
    z_name = lang_n                             # zip file path
    if wav_n == "True":
        name = z_name + "_w"
    z_name = z_name+"_"+format_n+".zip"
    
        # Check if zip already exists
    if os.path.isfile(z_name):
        return FileResponse(z_name,content_type="application/zip")
        # Query the contributions
        # Get the links
    l_links = [("WS1_4a_Algn.TextGrid","hdl.handle.net/11280/30ccd33e"),
               ("WS1_4A.eaf","hdl.handle.net/11280/4759b29d")]
    d_files = {"WS1_4A":l_links}
        # Get the citations
        # Download
    lang_path = os.path.join(s_path,lang_n)
    if not os.path.isdir(lang_path):
        os.mkdir(lang_path)
    for name,l_urls in d_files.items():
        trans_path = os.path.join(lang_path,name)
        if not os.path.isdir(trans_path):
            os.mkdir(trans_path)
        for f_name,url in l_urls:
            res_path = os.path.join(trans_path,f_name)
            if os.path.isfile(res_path):
                continue
            url = nakala+"/"+url.split("/",1)[1]
            response = request.urlopen(url)
            with open(res_path,'wb') as fi:
                fi.write(response.read())
        # Zip
    with tempfile.NamedTemporaryFile(delete=True) as output:
        zf = zipfile.ZipFile(output,'w', zipfile.ZIP_DEFLATED)
        for root,dirs,files in os.walk(lang_path):
            dir = root.split(s_path,1)[1]
            for file in files:
                zf.write(os.path.join(root,file),
                         arcname=os.path.join(dir,file))
        zf.close(); del zf
        shutil.rmtree(lang_path) # using 'shutil' to remove NAKALA files
        response = FileResponse(os.path.abspath(output.name))
        response.headers['Content-Type'] = 'application/zip'
        response.headers['Content-Disposition'] = 'filename="'+z_name+'"'
        return response

